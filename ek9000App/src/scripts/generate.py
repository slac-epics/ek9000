#!/usr/bin/python3
# 
# Author: Jeremy Lorelli
#
# From terminals.json, this script generates:
#   * ../../../SupportedDevices.md
#   * ../terminals.h (as designated by -o)
#   * ../../Db/Templates.mak (Makefile for including all auto-generated templates)
#   * ../../Db/*.template
#   * ../../Db/*.substitutions

import argparse
import json
import os
import sys

import CppTk

"""

JSON SYNTAX:


{
    "name": "EL3202",       // Name of the terminal
    "type": "AnalogIn",     // Type AnalogIn, AnalogOut, DigIn, DigOut
    "inputs": 2,            // Number of input channels
    "outputs": 0,           // Number of output channels
    "pdo_in_size": 4,       // PDO input size. For Digital terminals, this is COILS. For Analog terms, this is REGISTERS (16-bits per reg)  
    "pdo_out_size": 0       // PDO output size. Same rules as in_size.
},

"""

parser = argparse.ArgumentParser(description="Generates a header containing information about each individual terminal")
parser.add_argument("file", metavar="file", type=str, nargs=1, help="The file to parse for terminal info")
parser.add_argument("--output", "-o", dest="output", action='store', required=True, type=str, help="The name of the output header")
parser.add_argument("--verify", dest="verify", action="store_const", const=1, help="Verify the json too.")
parser.add_argument("--verbose", dest="verbose", action='store_true', help='Run with extra debug inf')
args = parser.parse_args()

#
# Files are in json format, check them out to figure out the actual syntax
#
file = args.file[0]
if not file or not os.path.exists(file):
    print("ERROR: Could not find input file.")
    sys.exit(1)

out = args.output
json_stuff = None
try:
    print("Parsing " + file)
    with open(file, "r") as fs:
        json_stuff = json.loads(fs.read())
except Exception as e:
    print("Error while parsing json:")
    print(str(e))
    sys.exit(1)

# Make a file to log the supported terminals in
fp = open("../../../SupportedDevices.md", "w")
fp.write("## Supported Devices\n\n")

header = CppTk.Header(out)
header.add_block_comment("\nAUTOGENERATED FILE: DO NOT EDIT.\n")
header.fs.write("#pragma once\n\n")
header.include_std("stddef.h")
header.include_std("stdint.h")
header.newline()
header.begin_struct("terminal_s")
header.add_variable("m_pString", "const char*")
header.add_variable("m_nID", "uint32_t")
header.add_variable("m_nOutputSize", "uint16_t")
header.add_variable("m_nInputSize", "uint16_t")
header.end_struct()
header.add_typedef("terminal_t", "terminal_s")
header.add_typedef("STerminalInfoConst_t", "terminal_t")
header.newlines(3)

try:
    count = 0
    vars = list()
    for terminal in json_stuff["terminals"]:
        count = count + 1
        name = terminal["name"]
        fp.write("* " + name)
        fp.write("\n")
        vars.append("&" + name + "_Info")
        outsize = terminal["pdo_out_size"]
        insize = terminal["pdo_in_size"]
        header.add_block_comment(name)
        header.add_define(name + "_STRING", '"' + name + '"')
        header.add_define(name + "_ID", name.replace("EL", ""))
        header.add_define(name + "_OUTPUT_SIZE", str(outsize))
        header.add_define(name + "_INPUT_SIZE", str(insize))
        header.add_init_struct("STerminalInfoConst_t", name + "_Info", name + "_STRING", name + "_ID",
                               name + "_OUTPUT_SIZE", name + "_INPUT_SIZE", static=True, const=True)
    header.newlines(2)
    header.add_array_variable("g_pTerminalInfos", "STerminalInfoConst_t*", vars, const=True, static=True)
except KeyError as e:
    print("Malformed JSON:")
    print("\tMissing the array key 'terminals'.")

fp.close()


class Terminal():
    def __init__(self, record: str, num: int, dtyp: str, typ: str):
        self.vals = dict()
        self.record = record
        self.num = num
        self.vals['DTYP'] = dtyp
        self.use_postfix = True
        if typ == 'DigInMulti' or typ == 'DigOutMulti':
            self.num = 1
            self.use_postfix = False

    # Adds a collection of values to the defaults list
    def add_values(self, _vals:dict):
        for v in _vals.items():
            self.vals[v[0]] = v[1]

    # Write this record out to fp
    def write(self, fp):
        for i in range(self.num):
            postfix = f':{i+1}' if self.use_postfix else ''
            fp.write(f'record({self.record},"$(TERMINAL){postfix}")\n{{\n')
            for i in self.vals.items():
                fp.write(f'\tfield({i[0]}, "{i[1]}")\n')
            fp.write('}\n\n')

    def set_default_bi(self):
        self.vals['ZNAM'] = 'low'
        self.vals['ONAM'] = 'high'
        self.vals['SCAN'] = 'I/O Intr'

    def set_default_mbbi(self):
        self.vals['SCAN'] = 'I/O Intr'
        
    def set_default_mbbo(self):
        pass

    def set_default_bo(self):
        self.vals['ZNAM'] = 'low'
        self.vals['ONAM'] = 'high'

    def set_default_ai(self):
        self.vals['LINR'] = 'LINEAR'
        self.vals['EGU'] = 'Volts'
        self.vals['SCAN'] = 'I/O Intr'

    def set_default_longin(self):
        self.vals['EGU'] = 'Counts'
        self.vals['SCAN'] = 'I/O Intr'

    def set_default_ao(self):
        self.vals['LINR'] = 'LINEAR'
        self.vals['EGU'] = 'Volts'


subs = \
    """
file $$FILE
{       pattern
        {
                TERMINAL,

        }
        {
        }
}
"""


# Returns the dtyp of the terminal
def get_dtyp(terminal: dict, type: str) -> str:
    try:
        return terminal["dtyp"]
    except KeyError:
        #type = terminal['type'][0] if isinstance(terminal['type'],list) else terminal['type']
        if type == "DigIn":
            return "EL10XX"
        elif type == "DigInMulti":
            return "EL10XX_mbbiDirect"
        elif type == "DigOut":
            return "EL20XX"
        elif type == 'DigOutMulti':
            return "EL20XX_mbboDirect"
        elif type == "AnalogIn":
            return "EL30XX"
        elif type == "AnalogOut":
            return "EL40XX"
        elif type == "PositionMeasurement":
            # Special-case the EL5042 dtype as we have custom support there
            if type == "EL5042":
                return "EL5042"
            return "EL5XXX"
        raise ValueError(f"Type is {type}")


def emit_terminal(terminal: dict, fp, type: str, extras: dict):
    # Add a postfix for mbbo/mbbi types
    postfix = '_mbbiDirect' if type == 'DigInMulti' else '_mbboDirect' if type == 'DigOutMulti' else ''
    template_filename = f'../../Db/{terminal["name"]}{postfix}.template'
    subs_filename = f'../../Db/{terminal["name"]}{postfix}.substitutions'
    
    name = terminal["name"]
    inputs = terminal["inputs"]
    outputs = terminal["outputs"]
    
    dtyp = get_dtyp(terminal, type)
    
    tfp = open(template_filename, "w")
    sfp = open(subs_filename, "w")
    if type == "DigIn":
        t = Terminal('bi', inputs, dtyp, type)
        t.set_default_bi()
    elif type == "DigOut":
        t = Terminal('bo', outputs, dtyp, type)
        t.set_default_bo()
    elif type == "AnalogIn":
        t = Terminal('ai', inputs, dtyp, type)
        t.set_default_ai()
    elif type == "AnalogOut":
        t = Terminal('ao', outputs, dtyp, type)
        t.set_default_ao()
    elif type == "PositionMeasurement":
        t = Terminal('longin', inputs, dtyp, type)
        t.set_default_longin()
    elif type == "DigInMulti":
        t = Terminal('mbbiDirect', inputs, dtyp, type)
        t.set_default_mbbi()
    elif type == "DigOutMulti":
        t = Terminal('mbboDirect', outputs, dtyp, type)
        t.set_default_mbbo()
    else:
        raise RuntimeError(f"Unexpected terminal type: {terminal}")
    t.add_values(extras)
    t.write(tfp)
    # Write out the subs
    sfp.write(subs.replace("$$FILE", f'{name}.template'))
    fp.write(f"# {name} \nDB += {template_filename} {subs_filename}\n\n")
    tfp.close()
    sfp.close()
    if args.verbose:
        print(f"Wrote {template_filename} and {subs_filename} (had {inputs} inputs and {outputs} outputs)")


def write_templates():
    with open("../../Db/Templates.mak", "w") as fp:
        print("Writing Templates.mak")
        fp.write("\n# AUTOGENERATED FILE, DO NOT EDIT\n\n")
        for terminal in json_stuff["terminals"]:    
            # Additional 'defaults'
            extras = {}
            try:
                extras = terminal['defaults']
            except:
                extras = {}
            
            if isinstance(terminal['type'],list):
                for t in terminal['type']:
                    emit_terminal(terminal, fp, t, extras)
            else:
                emit_terminal(terminal, fp, terminal['type'], extras)
        fp.write("\n\n")

write_templates()
