#!/usr/bin/python3
#
# From terminals.json, this script generates:
#   * ../../../SupportedDevices.md
#   * ../terminals.h (as designated by -o)
#   * ../../Db/Templates.mak (Makefile for including all auto-generated templates)
#   * ../../Db/*.template
#   * ../../Db/*.substitutions

import argparse
import json
from typing import TypedDict, Tuple

"""

JSON SYNTAX:


{
    "name": "EL3202",       // Name of the terminal
    "type": "AnalogIn",     // Type AnalogIn, AnalogOut, DigIn, DigOut
    "inputs": 2,            // Number of input channels
    "outputs": 0,           // Number of output channels
    "pdo_in_size": 4,       // PDO input size. For Digital terminals, this is COILS. For Analog terms, this is REGISTERS (16-bits per reg)  
    "pdo_out_size": 0       // PDO output size. Same rules as in_size.
},

"""

parser = argparse.ArgumentParser(description="Generates a header containing information about each individual terminal")
parser.add_argument("file", metavar="file", type=str, nargs=1, help="The file to parse for terminal info")
parser.add_argument("--output", "-o", dest="output", action='store', required=True, type=str, help="The name of the output header")
parser.add_argument("--verify", dest="verify", action="store_const", const=1, help="Verify the json too.")
parser.add_argument("--verbose", dest="verbose", action='store_true', help='Run with extra debug inf')
args = parser.parse_args()


class SpecType(TypedDict):
    resolution: int
    representation: str
    egu: str
    min: float
    max: float
    error: float


class TerminalType(TypedDict):
    name: str
    type: str | list[str]
    dtyp: str
    inputs: int
    outputs: int
    pdo_in_size: int
    pdo_out_size: int
    spec: SpecType


def is_digital(terminal: dict) -> bool:
    type = terminal['type']
    return 'DigIn' in type or 'DigOut' in type


def load_terminals(file: str) -> list[TerminalType]:
    """
    Loads the terminals.json file, returning a dict
    If this fails, it throws
    
    Parameters
    ----------
    file : str
        Path to terminals.json
        
    Returns
    -------
    dict
        Data from terminals.json
    """
    with open(file, 'r') as fp:
        return json.load(fp)['terminals']


def write_terminal_header(terms: dict, out: str):
    """
    Writes the terminal_types.h header, which contains the structures generated
    from terminals.json
    
    Parameters
    ----------
    terms : dict
        Dict of terminals from terminals.json
    out : str
        Target output file (usually terminal_types.json)
        
    Returns
    -------
    list[str]
        Terminal types written to the header
    """
    with open(out, 'w') as fp:
        fp.write('// WARNING: This header was generated by scripts/generate.py! Do not edit!\n\n#pragma once\n\n')
        fp.write('#include "terminal.h"\n#include "ekUtil.h"\n\n')
        terminalTypes = []
        for term in terms:
            name = term['name']
            terminalTypes.append(name)
            
            # Write out check prototypes
            checks = ''
            if not is_digital(term):
                if term['pdo_in_size'] > 0:
                    checks += '\tstatic void _pdo_input_check();\n'
                if term['pdo_out_size'] > 0:
                    checks += '\tstatic void _pdo_output_check();\n'

            fp.write(
f"""
struct {name}_t FINAL : terminal_t {{
    static const uint32_t ID = {name.replace('EL','')};
    static const uint16_t NUM_INPUTS = {term['inputs']};
    static const uint16_t INPUT_SIZE = {term['pdo_in_size']};
    static const uint16_t NUM_OUTPUTS = {term['outputs']};
    static const uint16_t OUTPUT_SIZE = {term['pdo_out_size']};
    {name}_t() {{
        str = "{name}";
        id = ID;
        numInputs = NUM_INPUTS;
        numOutputs = NUM_OUTPUTS;
        inputSize = INPUT_SIZE;
        outputSize = OUTPUT_SIZE;
    }}
    {checks}
}};\n\n
"""
            )
        
        # Write out the terminal infos array
        fp.write('static const terminal_t s_terminalInfos[] = {\n')
        for type in terminalTypes:
            fp.write(f'\t{type}_t(),\n')
        fp.write('};\n\n')
        
        # Write out the PDO checks
        fp.write('MAYBE_UNUSED static void __pdo_check() {\n')
        for term in terms:
            if is_digital(term):
                continue
            type = f'{term["name"]}_t'
            if term['pdo_in_size'] > 0:
                fp.write(f'\t{type}::_pdo_input_check();\n')
            if term['pdo_out_size'] > 0:
                fp.write(f'\t{type}::_pdo_output_check();\n')
        fp.write('}\n\n')


def write_supported_terminals(terms: dict) -> None:
    """
    Writes the list of supported terminals to a markdown document in the root of the module's directory
    
    Parameters
    ----------
    terms : dict
        Terminals dict
    """
    with open('../../../SupportedDevices.md', 'w') as fp:
        fp.write('# Supported Terminals\n\n')
        for t in terms:
            fp.write(f'* {t["name"]}\n')
        fp.write('\n\n')


class Terminal():
    def __init__(self, record: str, num: int, dtyp: str, typ: str, spec: SpecType|None = None):
        self.vals = dict()
        self.record = record
        self.num = num
        self.vals['DTYP'] = dtyp
        self.use_postfix = True
        self.spec = spec
        if typ == 'DigInMulti' or typ == 'DigOutMulti':
            self.num = 1
            self.use_postfix = False


    # Adds a collection of values to the defaults list
    def add_values(self, _vals:dict):
        for v in _vals.items():
            self.vals[v[0]] = v[1]


    # Write this record out to fp
    def write(self, fp):
        for i in range(self.num):
            postfix = f':{i+1}' if self.use_postfix else ''
            fp.write(f'record({self.record},"$(TERMINAL){postfix}")\n{{\n')
            for i in self.vals.items():
                fp.write(f'\tfield({i[0]}, "{i[1]}")\n')
            fp.write('}\n\n')


    @staticmethod
    def _get_raw_range(spec: SpecType) -> Tuple[int,int]:
        """
        Computes the raw range for the terminal
        
        Returns
        -------
        Tuple[int,int]:
            Range interval (min,max)
        """
        # if min is < 0, raw ADC value will be signed. All AO and AI terminals sign extend to int16, but that only really matters
        # when the range starts at <0
        bits = spec['resolution'] if spec['min'] >= 0 else spec['resolution']-1
        targetBits = 0
        match spec['representation']:
            case 'int16':
                targetBits = 16
            case other:
                assert False
        # Compute a shift for terminals where ADC resolution != representation
        shift = 0 if bits == targetBits else targetBits-bits-1
        max = (1<<bits<<shift)-1
        min = -max if spec['min'] < 0 else (1<<shift) # TODO: Validate this for signed terminals.
        return (min, max)


    @staticmethod
    def _compute_deadbands(spec: SpecType) -> float:
        """
        Compute deadband parameters ADEL and MDEL based on max raw value and error specified in datasheet
        Most terminals are rated for measurement error of <0.3%
        
        Returns
        -------
        float:
            The value ADEL and MDEL should be set to
        """
        error = spec['error'] / 100.0 # error is in %, convert that to float
        return spec['max'] * error # Docs specify that error is relative to the full scale value


    def _compute_analog_defaults(self) -> dict:
        """
        Compute ESLO, EOFF, EGUF and EGUL for the analog I/O terminal
        
        Returns
        -------
        dict:
            Mapping of PV -> values
        """

        if self.spec is None:
            return {}

        rawMin, rawMax = self._get_raw_range(self.spec)
        range = self.spec['max'] - self.spec['min']
        deadband = self._compute_deadbands(self.spec)
        return {
            'ESLO': (range / (rawMax-rawMin)),
            'EOFF': (rawMax * self.spec['min'] - rawMin * self.spec['max']) / (rawMax-rawMin),
            'EGUF': self.spec['max'],
            'EGUL': self.spec['min'],
            'EGU': self.spec['egu'],
            'LINR': 'LINEAR',
            'ADEL': deadband,
            'MDEL': deadband
        }


    def set_default_bi(self):
        self.vals['ZNAM'] = 'low'
        self.vals['ONAM'] = 'high'
        self.vals['SCAN'] = 'I/O Intr'


    def set_default_mbbi(self):
        self.vals['SCAN'] = 'I/O Intr'


    def set_default_mbbo(self):
        pass


    def set_default_bo(self):
        self.vals['ZNAM'] = 'low'
        self.vals['ONAM'] = 'high'


    def set_default_ai(self):
        self.vals['LINR'] = 'LINEAR'
        self.vals['EGU'] = 'V'
        self.vals['SCAN'] = 'I/O Intr'
        self.vals['PREC'] = '3'
        self.vals.update(self._compute_analog_defaults())


    def set_default_longin(self):
        self.vals['EGU'] = 'Counts'
        self.vals['SCAN'] = 'I/O Intr'


    def set_default_ao(self):
        self.vals['LINR'] = 'LINEAR'
        self.vals['EGU'] = 'V'
        self.vals['PREC'] = '3'
        self.vals.update(self._compute_analog_defaults())


subs = \
    """
file $$FILE
{       pattern
        {
                TERMINAL,

        }
        {
        }
}
"""


# Returns the dtyp of the terminal
def get_dtyp(terminal: dict, type: str) -> str:
    try:
        return terminal["dtyp"]
    except KeyError:
        #type = terminal['type'][0] if isinstance(terminal['type'],list) else terminal['type']
        if type == "DigIn":
            return "EL10XX"
        elif type == "DigInMulti":
            return "EL10XX_mbbiDirect"
        elif type == "DigOut":
            return "EL20XX"
        elif type == 'DigOutMulti':
            return "EL20XX_mbboDirect"
        elif type == "AnalogIn":
            return "EL30XX"
        elif type == "AnalogOut":
            return "EL40XX"
        elif type == "PositionMeasurement":
            # Special-case the EL5042 dtype as we have custom support there
            if type == "EL5042":
                return "EL5042"
            return "EL5XXX"
        raise ValueError(f"Type is {type}")


def emit_terminal(terminal: dict, fp, type: str, extras: dict):
    # Add a postfix for mbbo/mbbi types
    postfix = '_mbbiDirect' if type == 'DigInMulti' else '_mbboDirect' if type == 'DigOutMulti' else ''
    template_filename = f'../../Db/{terminal["name"]}{postfix}.template'
    subs_filename = f'../../Db/{terminal["name"]}{postfix}.substitutions'
    
    name = terminal["name"]
    inputs = terminal["inputs"]
    outputs = terminal["outputs"]
    spec: SpecType = terminal["specs"] if "specs" in terminal else None
    
    dtyp = get_dtyp(terminal, type)
    
    tfp = open(template_filename, "w")
    sfp = open(subs_filename, "w")
    if type == "DigIn":
        t = Terminal('bi', inputs, dtyp, type)
        t.set_default_bi()
    elif type == "DigOut":
        t = Terminal('bo', outputs, dtyp, type)
        t.set_default_bo()
    elif type == "AnalogIn":
        t = Terminal('ai', inputs, dtyp, type, spec)
        t.set_default_ai()
    elif type == "AnalogOut":
        t = Terminal('ao', outputs, dtyp, type, spec)
        t.set_default_ao()
    elif type == "PositionMeasurement":
        t = Terminal('longin', inputs, dtyp, type)
        t.set_default_longin()
    elif type == "DigInMulti":
        t = Terminal('mbbiDirect', inputs, dtyp, type)
        t.set_default_mbbi()
    elif type == "DigOutMulti":
        t = Terminal('mbboDirect', outputs, dtyp, type)
        t.set_default_mbbo()
    else:
        raise RuntimeError(f"Unexpected terminal type: {terminal}")
    t.add_values(extras)
    t.write(tfp)
    # Write out the subs
    sfp.write(subs.replace("$$FILE", f'{name}.template'))
    fp.write(f"# {name} \nDB += {template_filename} {subs_filename}\n\n")
    tfp.close()
    sfp.close()
    if args.verbose:
        print(f"Wrote {template_filename} and {subs_filename} (had {inputs} inputs and {outputs} outputs)")


def write_templates(terms: dict):
    """
    Writes out templates and substitutions for all supported terminals
    
    Parameters
    ----------
    terms : dict
        Dict containing all terminals
    """
    with open("../../Db/Templates.mak", "w") as fp:
        print("Writing Templates.mak")
        fp.write("\n# AUTOGENERATED FILE, DO NOT EDIT\n\n")
        for terminal in terms:
            # Additional 'defaults'
            extras = {}
            try:
                extras = terminal['defaults']
            except:
                extras = {}
            
            if isinstance(terminal['type'],list):
                for t in terminal['type']:
                    emit_terminal(terminal, fp, t, extras)
            else:
                emit_terminal(terminal, fp, terminal['type'], extras)
        fp.write("\n\n")


def main():
    terminalData = load_terminals(args.file[0])
    write_templates(terminalData)
    write_terminal_header(terminalData, args.output)
    write_supported_terminals(terminalData)


if __name__ == '__main__':
    main()


# vim: et:ts=4:syn=py
